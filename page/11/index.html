<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="Tu5vqPaUb8svfkPx5eetJFD84ciQCcWVXNatdsWtj9Q">
  <meta name="baidu-site-verification" content="baidu_verify_FBq9PG4BBb">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sliu.vip","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","width":240,"display":"hide","padding":12,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"PXY1Z6GHKT","apiKey":"eb82f2e78e3053f26aa408e9caa96d93","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"要查点什么(✿◡‿◡)","hits_empty":"没有找到任何关于 ${query} 的结果╥﹏╥...","hits_stats":"搜索到 ${hits} 条记录，用时 ${time} ms o(*￣▽￣*)ブ"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="不成为自己讨厌的人">
<meta property="og:type" content="website">
<meta property="og:title" content="刘硕的技术查阅手册">
<meta property="og:url" content="https://sliu.vip/page/11/index.html">
<meta property="og:site_name" content="刘硕的技术查阅手册">
<meta property="og:description" content="不成为自己讨厌的人">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘硕">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="全栈开发">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="网络编程">
<meta property="article:tag" content="爬虫">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="自动化测试">
<meta property="article:tag" content="Web开发">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="jQuery">
<meta property="article:tag" content="Bootstrap">
<meta property="article:tag" content="测试自动化">
<meta property="article:tag" content="Selenium">
<meta property="article:tag" content="postman">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Vue">
<meta property="article:tag" content="drf">
<meta property="article:tag" content="django">
<meta property="article:tag" content="文档翻译">
<meta property="article:tag" content="PEP8">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sliu.vip/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>刘硕的技术查阅手册</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f14f123935d6183fdd06f8f1c4bc378f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="刘硕的技术查阅手册" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">刘硕的技术查阅手册</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Python 全栈开发学习笔记</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-toc">

    <a href="/toc/" rel="section"><i class="fa fa-fw fa-book"></i>总目录</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-fw fa-rss"></i>订阅</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-advanced/design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-advanced/design-pattern/" class="post-title-link" itemprop="url">常见设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先想象一下这样一个场景：去麦当劳点餐，我们想吃麦辣鸡腿堡、薯条和可乐。我们当然可以单点，但是如果我们对收银小姐姐说，请给我一份麦辣鸡腿堡套餐，就会方便很多。套餐是餐厅和我们约定好了的一个规范，如果大家都按照这个规范来点餐，就能够提高点餐效率。</p>
<p>创建套餐是提高点餐效率的可重复使用的解决方法。套餐可以重复被点，而且提高了顾客和服务员之间的共同效率。</p>
<p>类似地，在编写程序的软件世界，对于统一情境，众多软件开发任意经过长时间总结出了最佳的可重用的解决方案，就是软件的设计模式。</p>
<p>软件世界本没有设计模式，开发人员多了，开发得久了，也便总结出了设计模式。</p>
<p>设计模式有很多很多种，对于不同的场景有不同的设计模式。这里只介绍两种非常常见的设计模式：单例模式和工厂模式。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>我们从前学习的类创建对象时，每个对象都是开辟相互独立的内存空间，它们各自的实例属性和方法是互无联系互不影响的。但是有的时候，我们只想创建一个对象，不管被实例化多少次，使用的对象都是一个。</p>
<p>比如在开发过程中，不同的程序员负责不同的模块。他们都需要使用到一个类对象，但是用了不同的名字。但是到后来当程序运行的时候，他们有需要这些对象都是同一个对象。这就需要用到单例模式。</p>
<p>单例模式是保证一个类仅有一个实例的设计模式。</p>
<p>单例模式保证了程序在不同位置都可以且尽可以取到同一个对象的实例：如果实例不存在，则会创建一个实例；如果对象存在，则会返回这个实力。</p>
<p>创建单例模式之前，我们要先讨论一下 <code>__new__()</code> 方法。同 <code>__init__()</code> 方法一样，<code>__new__()</code> 方法也是在创建对象时自动运行的。不同的是，<code>__init__()</code> 方法用来初始化对象，而 <code>__new()__</code> 方法用来创建对象。</p>
<p>换句话说，<code>__new__()</code> 方法在对象创建之前就会运行，它是一个类方法。它的返回值就是新创建的对象。</p>
<p>有了这些基础，结合我们从前学过的东西，就可以创建一个单例模式的类了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="comment"># 类属性，用来存放实例对象内存地址，同时也用来标记类是否已经被实例化，初始值为None</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cls用来指代类，args和kwargs用来接收参数，PyCharm默认填入，不必理会也不必修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 如果没有实例化，就对其进行实例化操作，将实例化后的对象储存到类属性instance中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.instance:</span><br><span class="line">            <span class="comment"># 这里的参数只放cls，不能放*args和**kwargs</span></span><br><span class="line">            cls.instance = object.__new__(cls)</span><br><span class="line">        <span class="comment"># 不管开始的instance是否为空，此时它都已经储存了一个类对象，将其返回即可</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaoli = Student(<span class="string">'小丽'</span>, <span class="number">16</span>)</span><br><span class="line">xiaoming = Student(<span class="string">'小明'</span>, <span class="number">18</span>)</span><br><span class="line">print(xiaoli.name)</span><br><span class="line">print(xiaoming.name)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">小明</span><br></pre></td></tr></table></figure>

<p>需要注意的是，虽然不会创建新的实例对象，但是每当创建新对象时，初始化方法 <code>__init__()</code> 还是会执行的。因为是同一个对象，所以后面创建的实例属性就会覆盖从前创建的实例属性。</p>
<p>因为单例模式太过常用且重要，所以我们往往将其单独写成一个类。继承这个单例模式类的新类也都会是单例模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.instance:</span><br><span class="line">            cls.instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaoli = Student(<span class="string">'小丽'</span>, <span class="number">16</span>)</span><br><span class="line">xiaoming = Student(<span class="string">'小明'</span>, <span class="number">18</span>)</span><br><span class="line">print(xiaoli.name)</span><br><span class="line">print(xiaoming.name)</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>我们现在有这样一个需求：我们玩王者荣耀，想要一个物理伤害，射程远，可以持续输出的英雄。如果我们自己去找，很慢而且很麻烦。需要我们遍历所有人物的职业，然后才能确定射手类是我们想要的。</p>
<p>但是我们其实可以把这件事情交给程序来做。只要我们提出需求（物理伤害，射程远，持续输出），程序自动给我们返回一个射手类的对象。这样就很方便了。</p>
<p>这个帮我们创建类的类就是一个工厂类。这种编程模式，就是工厂模式。</p>
<p>工厂模式就是不直接暴露对象的创建细节，而是通过一个共同的类来创建对象的模式，总共需要四个步骤：</p>
<ol>
<li>创建基类</li>
<li>创建子类</li>
<li>创建工厂类</li>
<li>使用工厂模式</li>
</ol>
<p>事实上，工厂类中待我们选择的类并不要求非要继承自同一个父类。而且其实 Python 中所有类都继承自 project 类。所以前两步可以合并为一步，创建类。</p>
<p>我们可以这样创建一个工厂模式的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello Mr.'</span> + self.get_name()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello Miss'</span> + self.get_name()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_person</span><span class="params">(self, name, gender=<span class="string">'M'</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> gender == <span class="string">'M'</span>:</span><br><span class="line">            <span class="keyword">return</span> Male(name)</span><br><span class="line">        <span class="keyword">if</span> gender == <span class="string">'F'</span>:</span><br><span class="line">            <span class="keyword">return</span> Female(name)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 使用工厂模式</span></span><br><span class="line">factory = Factory()</span><br><span class="line">person = fcatory.get_person(<span class="string">'Bob'</span>, <span class="string">'M'</span>)</span><br><span class="line">print(person)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-advanced/encapsulation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-advanced/encapsulation/" class="post-title-link" itemprop="url">封装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>“封装”就是将抽象得到的数据和行为相结合，形成一个有机整体</p>
<ul>
<li>元组，列表，字典等等：数据的封装，通过引用去使用数据</li>
<li>函数：算法的封装<ul>
<li>如果没有函数，功能要靠每一行代码去直接执行</li>
<li>没有函数的话，耦合度会很高，复用性很差，开发效率也非常低</li>
</ul>
</li>
</ul>
<p>封装的目的是简化编程和增加安全性</p>
<ul>
<li>使用者不必关系具体的实现细节</li>
<li>通过接口（万能的点 <code>.</code>）</li>
<li>还可以给予特定的访问权限来使用类的成员</li>
<li>明确区分内外<ul>
<li><code>类的实现者</code> 可以修改内部封装的东西而不影响外部调用者</li>
<li><code>外部调用者</code> 只需要直到自己可以使用该类对象的哪些功能</li>
</ul>
</li>
</ul>
<p>私有属性和私有方法</p>
<ul>
<li>标识符以双下划线 <code>__</code> 开头的是私有成员，在外部不可以直接用这种属性或方法名调用，子类中也不能访问到这个数据</li>
<li>可以提供外界访问的接口<ul>
<li>将不需要对外提供的内容都隐藏起来</li>
<li>把属性都隐藏，提供公共方法对其访问</li>
</ul>
</li>
<li>双下划线开头的属性在继承给子类时，子类是无法覆盖的</li>
</ul>
<p>私有方法示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self.__age = age</span><br><span class="line">xiaoming = Person(<span class="string">'小明'</span>, <span class="number">17</span>)</span><br><span class="line"><span class="comment"># print(xiaoming.__age)    # 程序会报错，找不到__age属性</span></span><br><span class="line">print(xiaoming.get_age())</span><br><span class="line">xiaoming.set_age(<span class="number">20</span>)</span><br><span class="line">print(xiaoming.get_age())</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>私有属性和私有方法并不是绝对不可以在外部访问和修改。我们可以通过在私有属性或方法名前加上 <code>_类名</code>，就可以调用私有属性和方法了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self.__age = age</span><br><span class="line">xiaoming = Person(<span class="string">'小明'</span>, <span class="number">17</span>)</span><br><span class="line">print(xiaoming._Person__age)</span><br><span class="line">xiaoming._Person__age = <span class="number">20</span></span><br><span class="line">print(xiaoming._Person__age)</span><br></pre></td></tr></table></figure>

<p>破解私有属性和私有方法：</p>
<ul>
<li>在名称前加上 <code>_类名</code></li>
<li>其实双下划线仅仅是一种变形操作：<ul>
<li>类中所有双下划线开头的名称如 <code>__x</code> 都会自动变形成：<code>_类名__x</code> 的形式</li>
</ul>
</li>
</ul>
<p>封装总结</p>
<ul>
<li>对外隐藏类内的具体实现，只提供接口，供外界使用</li>
<li>可以将属性和方法设置成私有的，<code>__</code>，设置成私有后，类内部可以访问，类外部无法访问</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-advanced/queue-rabbitmq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-advanced/queue-rabbitmq/" class="post-title-link" itemprop="url">消息队列和 RabbitMQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>消息队列和 RabbitMQ 的用法。消息队列是针对生产者消费者模型的解决方案，解耦合。RabbitMQ 是一款经典的消息队列工具。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/python-advanced/queue-rabbitmq/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-advanced/ooa-ood-oop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-advanced/ooa-ood-oop/" class="post-title-link" itemprop="url">OOA、OOD 和 OOP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>OOA</code>，Object Oriented Analysis，面向对象分析法</p>
<ul>
<li>指的是在一个系统的开发过程中，进行了系统业务调查以后，按照面向对象的思想来分析问题</li>
<li>OOA的主要原则：<ol>
<li>抽象：从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质的特征，就叫抽象</li>
<li>封装：把对象的属性和服务结合为一个不可分的系统单位，并尽可能隐蔽对象的内部细节</li>
<li>继承：特殊类的对象拥有的其一般的类的全部属性与服务</li>
<li>聚合：又称组装，其原则是把一个复杂的事务堪称若干个比较简单的事物组装体，从而简化对复杂事物的描述。</li>
<li>关联：是人类思考问题时经常运用的思想方法，通过一个事物联想到另外的事物</li>
</ol>
</li>
</ul>
<p><code>OOD</code>，Object Oriented Design，面向对象设计</p>
<ul>
<li>该方法是<code>oo</code>方法中一个中间过渡环节</li>
<li>主要作用是对<code>OOA</code>分析的结构做进一步的规范化整理，以便能够被<code>OOP</code>直接接受</li>
<li>根据需求决定所需的类、类的操作以及类之间关联的过程</li>
<li>是一个软件设计方法，是一种工程化规范</li>
</ul>
<p><code>OOP</code>，Object Oriented Programming，面向对象程序设计</p>
<ul>
<li>是一种计算机变成架构，一种编程思想</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-advanced/object-oriented/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-advanced/object-oriented/" class="post-title-link" itemprop="url">面向对象初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><p>编程语言发展历程：</p>
<p>机器语言 –&gt; 汇编语言 –&gt; 高级语言</p>
<p>数学向左，上帝向右。数学家的思维总是倾向于将事物抽象化，寻求程序运行效率的最大化。但是正常人的思维赶不上数学家的思维。而且在硬件运行速度足够快，内存空间足够大的今天，已经不特别在意程序的运行速度。人们更在意的是程序的开发速度。面向对象的编程思想应运而生。</p>
<p>面向过程</p>
<ul>
<li>事件为中心：分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用</li>
<li>维护、复用、扩展性差</li>
</ul>
<p>面向对象</p>
<ul>
<li>与面向对象相辅相成，在软件开发过程中，宏观上，用面向对象来把握事件间复杂的关系</li>
<li>性能低于面向过程</li>
</ul>
<p>举一个通俗一点的例子，我们想要开一家饭店，如果用面向过程的方法，我们就要自己租房子，买菜，接待客人，做菜，擦桌子，洗盘子等等。如果用面向对象的方法，租房子我们去找中介，买菜去找采购，做菜找厨师，接待客人招服务员等等。</p>
<p>需要指明的是，面向过程和面向对象不属于任何一门编程语言，它们只是两种不同的编程思想。</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类是对象的抽象，是一类事物的总称；</p>
<p>对象是类的具象，是一个具体的事物。</p>
<p>先有类，通过类可以创建对象。</p>
<p>数据类型是数据的封装，函数是算法的封装。</p>
<p>类是数据和算法的封装，更高一级。</p>
<p>区分类和对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">狗    <span class="comment"># 类</span></span><br><span class="line">奥迪A8    <span class="comment"># 类</span></span><br><span class="line">电脑    <span class="comment"># 类</span></span><br><span class="line">我的电脑    <span class="comment"># 对象</span></span><br><span class="line">苹果    <span class="comment"># 类</span></span><br><span class="line">我现在坐的椅子    <span class="comment"># 对象</span></span><br><span class="line">男人    <span class="comment"># 类</span></span><br><span class="line">我的女朋友    <span class="comment"># 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>我们使用 <code>class</code> 关键字创建一个类，类名要求同变量命名规则类似，同时要求首字母要大写。创建类时，类名后可以不加括号，如果一定要加括号，记得在里面加上 object：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一，类名后面加(object)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span><span class="params">(object)</span>:</span></span><br><span class="line">    sex = <span class="string">'女'</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 方法二，类名后什么都不加</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span>:</span></span><br><span class="line">    sex = <span class="string">'女'</span></span><br></pre></td></tr></table></figure>

<p>使用伪代码来表示，我们可以这样创建一个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(父类)</span>:</span></span><br><span class="line">    属性</span><br><span class="line">    方法</span><br></pre></td></tr></table></figure>

<p>类中包含属性（特征）和方法（行为）。属性通常是变量，用来表示类是什么样的；方法通常是函数，用来体现类能干什么。</p>
<p>我们可以通过 <code>.__dict__</code> 方法查看类中的所有内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span>:</span></span><br><span class="line">    name = <span class="string">'小丽'</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    height = <span class="number">172</span></span><br><span class="line">    weight = <span class="number">100</span></span><br><span class="line">    money = <span class="number">10000000000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chui_tui</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'给主子捶腿~'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">give_money</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'给你100元'</span>)</span><br><span class="line">        self.money -= <span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(GirlFriend.__dict__)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'name'</span>: <span class="string">'小丽'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'height'</span>: <span class="number">172</span>, <span class="string">'weight'</span>: <span class="number">100</span>, <span class="string">'money'</span>: <span class="number">10000000000</span>, <span class="string">'chui_tui'</span>: &lt;function GirlFriend.chui_tui at <span class="number">0x00000267C73BDB70</span>&gt;, <span class="string">'give_money'</span>: &lt;function GirlFriend.give_money at <span class="number">0x00000267C73BDAE8</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'GirlFriend'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'GirlFriend'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>name</code>、<code>age</code>、<code>height</code>、<code>weight</code>、<code>money</code> 都是类的属性。<code>chui_tui</code> 和 <code>give_money</code> 是类的方法。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象的创建和调用方法用伪代码表示是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象名 = 类名()    <span class="comment"># 创建一个类对象</span></span><br><span class="line"></span><br><span class="line">对象名.属性名    <span class="comment"># 调用类属性</span></span><br><span class="line">对象名.方法名()   <span class="comment"># 调用类方法</span></span><br><span class="line"></span><br><span class="line">对象名.属性名 = 属性值    <span class="comment"># 为当前对象添加新属性</span></span><br></pre></td></tr></table></figure>

<p>为当前对象添加新方法的方式比较繁琐，也不常用，仅作了解即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types    <span class="comment"># 先导入types方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>    <span class="comment"># 创建类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span>    <span class="comment"># 需要添加的函数，注意要使用self作为第一个参数</span></span><br><span class="line">    print(<span class="string">'吃东西'</span>)</span><br><span class="line"></span><br><span class="line">xiaoming = Person(<span class="string">'小明'</span>)    <span class="comment"># 创建一个对象</span></span><br><span class="line">xiaoming.eat = types.MethodType(eat, xiaoming)    <span class="comment"># MethodType方法有两个参数，第一个参数是要像对象中添加的方法，第二个参数是接受方法的对象</span></span><br><span class="line">xiaoming.eat()    <span class="comment"># 此时，对象中已经存在eat方法</span></span><br></pre></td></tr></table></figure>

<h3 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h3><p>类属性</p>
<ul>
<li>属于类</li>
<li>当前类的所有对象该属性的值都一样</li>
<li>类对象推荐直接用类名访问，虽然也可以使用对象名访问（不推荐）</li>
<li>改变类变量的值，会作用于该类所有的实例化对象</li>
<li>可以通过类名在类外添加新的类属性</li>
</ul>
<p>具体示例为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span>:</span></span><br><span class="line">    name = <span class="string">'小丽'</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    height = <span class="number">172</span></span><br><span class="line">    weight = <span class="number">100</span></span><br><span class="line">    money = <span class="number">10000000000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chui_tui</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'给主子捶腿~'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">give_money</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'给你100元'</span>)</span><br><span class="line">        self.money -= <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">xiaoli = GirlFriend()</span><br><span class="line">xiaohong = GirlFriend()</span><br><span class="line">print(xiaoli.name, xiaohong.name, GirlFriend.name)</span><br><span class="line">GirlFriend.age = <span class="number">16</span></span><br><span class="line">print(xiaoli.age, xiaohong.age, GirlFriend.age)</span><br><span class="line">GirlFriend.color = <span class="string">'white'</span></span><br><span class="line">print(xiaoli.color, xiaohong.color, GirlFriend.color)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小丽 小丽 小丽</span><br><span class="line"><span class="number">16</span> <span class="number">16</span> <span class="number">16</span></span><br><span class="line">white white white</span><br></pre></td></tr></table></figure>

<p>实例属性（类属性）</p>
<ul>
<li><p>实例属性（实例变量）需要使用初始化方法来定义，用伪代码表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>    <span class="comment"># self只能在类内使用，在类外使用则无效</span></span><br><span class="line">        self.name = name    <span class="comment"># 形参可以和示例变量名相同，也常这样写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属于对象</p>
</li>
<li><p>当前类的对象可以拥有各自的属性值</p>
</li>
<li><p>实例变量只能通过对象名访问，无法通过类名直接访问</p>
</li>
<li><p>实例属性不仅可以在 <code>__init__</code> 方法里添加，还可以在类的其他方法中添加</p>
</li>
<li><p>查询对象中所有属性的方法为：<code>对象.__dict__</code></p>
</li>
</ul>
<p>具体操作实例为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span>:</span></span><br><span class="line">    eye_num = <span class="number">2</span></span><br><span class="line">    sex = <span class="string">'女'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chui_tui</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>给大哥捶<span class="subst">&#123;num&#125;</span>次腿'</span>)</span><br><span class="line">        self.love = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">xiaoli = GirlFriend(<span class="string">'小丽'</span>, <span class="number">16</span>)</span><br><span class="line">xiaohong = GirlFriend(<span class="string">'小红'</span>, <span class="number">17</span>)</span><br><span class="line">xiaoli.chui_tui(<span class="number">10</span>)</span><br><span class="line">print(xiaoli.love)</span><br><span class="line"></span><br><span class="line">输出的结果为：</span><br><span class="line">小丽给大哥捶<span class="number">10</span>次腿</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>类对象和实例对象有几点需要注意：</p>
<ul>
<li>Python 允许通过对象访问类变量，但无法通过对象修改变量的值</li>
<li>通过对象修改变量的值，不是在给 <code>变量赋值</code>，而是定义新的实例变量</li>
<li>实例变量可以和类变量同名，但是在这种情况下，使用类对象将无法调用示实例变量<a href="这一点可以理解为变量的查找是有顺寻的，优先查找实例变量。当实例变量不存在时，去查找类变量。">^1</a></li>
<li>修改一个对象的实例变量，既不会影响类变量的值，也不会影响其他对象的实例变量</li>
</ul>
<p>上述说明用实例验证如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span>:</span></span><br><span class="line">    name = <span class="string">'小丽丽'</span></span><br><span class="line">    eye_num = <span class="number">2</span></span><br><span class="line">    sex = <span class="string">'女'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chui_tui</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>给大哥捶<span class="subst">&#123;num&#125;</span>次腿'</span>)</span><br><span class="line">        self.love = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">xiaoli = GirlFriend(<span class="string">'小丽'</span>, <span class="number">16</span>)</span><br><span class="line">xiaohong = GirlFriend(<span class="string">'小红'</span>, <span class="number">17</span>)</span><br><span class="line">print(xiaoli.sex)    <span class="comment"># 女</span></span><br><span class="line">print(GirlFriend.__dict__[<span class="string">'sex'</span>])    <span class="comment"># 女</span></span><br><span class="line">print(xiaoli.__dict__)    <span class="comment"># &#123;'name': '小丽', 'age': 16&#125;</span></span><br><span class="line">xiaoli.sex = <span class="string">'保密'</span></span><br><span class="line">print(GirlFriend.__dict__[<span class="string">'sex'</span>])    <span class="comment"># 女</span></span><br><span class="line">print(xiaoli.__dict__)    <span class="comment"># &#123;'name': '小丽', 'age': 16, 'sex': '保密'&#125;</span></span><br><span class="line">print(xiaohong.name)    <span class="comment"># 小红</span></span><br><span class="line">xiaoli.name = <span class="string">'小莉'</span></span><br><span class="line">print(GirlFriend.__dict__[<span class="string">'name'</span>])    <span class="comment"># 小丽丽</span></span><br><span class="line">print(xiaoli.__dict__[<span class="string">'name'</span>])    <span class="comment"># 小莉</span></span><br><span class="line">print(xiaohong.__dict__[<span class="string">'name'</span>])    <span class="comment"># 小红</span></span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">女</span><br><span class="line">女</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'小丽'</span>, <span class="string">'age'</span>: <span class="number">16</span>&#125;</span><br><span class="line">女</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'小丽'</span>, <span class="string">'age'</span>: <span class="number">16</span>, <span class="string">'sex'</span>: <span class="string">'保密'</span>&#125;</span><br><span class="line">小红</span><br><span class="line">小丽丽</span><br><span class="line">小莉</span><br><span class="line">小红</span><br></pre></td></tr></table></figure>

<h3 id="系统类"><a href="#系统类" class="headerlink" title="系统类"></a>系统类</h3><p>Python 无处不对象。比如，我们创建列表就是在进行类的实例化和调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = list()    <span class="comment"># Python中内置了一个list类，这里直接进行实例化</span></span><br><span class="line">list1.append(<span class="number">1</span>)    <span class="comment"># 调用list类中的append方法</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-advanced/class-relationship/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-advanced/class-relationship/" class="post-title-link" itemprop="url">类之间的依赖关系和组合关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="依赖（关联）关系"><a href="#依赖（关联）关系" class="headerlink" title="依赖（关联）关系"></a>依赖（关联）关系</h3><p>类之间可以有三种关系：</p>
<ol>
<li>依赖（关联）关系</li>
<li>组合（聚合）关系</li>
<li>继承（实现）关系</li>
</ol>
<p>依赖（关联）关系指的是类对象执行某个动作的时候，需要其他类的对象来帮助完成这个操作的情况，其特点为：</p>
<ul>
<li>将一个类的对象或者类名传到另一个类的方法中使用</li>
<li>此时的关系是最轻的，随时可以更换其他对象</li>
</ul>
<p>关联关系的示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self, tools)</span>:</span></span><br><span class="line">        tools.run()</span><br><span class="line">        print(<span class="string">'我要打游戏了'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'电脑已经打开，DNF已经登陆'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'王者荣耀已经登陆'</span>)</span><br><span class="line">xiaoming = Person()</span><br><span class="line">xmPhone = Phone()</span><br><span class="line">hwComp = Computer()</span><br><span class="line">xiaoming.play(xmPhone)</span><br><span class="line">xiaoming.play(hwComp)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">王者荣耀已经登陆</span><br><span class="line">我要打游戏了</span><br><span class="line">电脑已经打开，DNF已经登陆</span><br><span class="line">我要打游戏了</span><br></pre></td></tr></table></figure>

<p>在这里补充两个删除对象的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delattr(对象名, <span class="string">'属性名'</span>)    <span class="comment"># 动态删除时比较常用</span></span><br><span class="line"><span class="keyword">del</span> 对象名.属性名</span><br></pre></td></tr></table></figure>

<p><code>del</code> 和 <code>delattr</code> 功能有限，只能删除实例属性，不能删除类属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span>:</span></span><br><span class="line">    name = <span class="string">'小丽丽'</span></span><br><span class="line">    eye_num = <span class="number">2</span></span><br><span class="line">    sex = <span class="string">'女'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chui_tui</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>给大哥捶<span class="subst">&#123;num&#125;</span>次腿'</span>)</span><br><span class="line">        self.love = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">xiaoli = GirlFriend(<span class="string">'小丽'</span>, <span class="number">16</span>)</span><br><span class="line">xiaohong = GirlFriend(<span class="string">'小红'</span>, <span class="number">17</span>)</span><br><span class="line"><span class="keyword">del</span> xiaoli.age</span><br><span class="line">delattr(xiaohong, <span class="string">'age'</span>)</span><br><span class="line">print(xiaoli.__dict__)</span><br><span class="line">print(xiaohong.__dict__)</span><br></pre></td></tr></table></figure>

<h3 id="组合（聚合）关系"><a href="#组合（聚合）关系" class="headerlink" title="组合（聚合）关系"></a>组合（聚合）关系</h3><p>组合（聚合）关系是对象里包含对象的关系：</p>
<ul>
<li>将一个类的对象封装到另一个类的对象的属性中，就叫组合<ul>
<li>一对一关系</li>
<li>一对多关系</li>
</ul>
</li>
</ul>
<p>一对一关系示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, girl_friend=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.girl_friend = girl_friend</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.girl_friend:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>带着他的女朋友<span class="subst">&#123;self.girl_friend.name&#125;</span>去吃饭'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'单身狗，吃狗粮！'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movie</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.girl_friend:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>带着他的女朋友<span class="subst">&#123;self.girl_friend.name&#125;</span>去看电影'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'单身狗不陪看电影！'</span>)</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">bao = BigB(<span class="string">'宝元'</span>)</span><br><span class="line">friend = Girl(<span class="string">'唐艺昕'</span>)</span><br><span class="line">bao.eat()</span><br><span class="line">bao.movie()</span><br><span class="line">bao.girl_friend = friend</span><br><span class="line">bao.eat()</span><br><span class="line">bao.movie()</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单身狗，吃狗粮！</span><br><span class="line">单身狗不陪看电影！</span><br><span class="line">宝元带着他的女朋友唐艺昕去吃饭</span><br><span class="line">宝元带着他的女朋友唐艺昕去看电影</span><br></pre></td></tr></table></figure>

<h3 id="一对多的组合关系"><a href="#一对多的组合关系" class="headerlink" title="一对多的组合关系"></a>一对多的组合关系</h3><p>同一对一的组合关系类似，我们可以将多个类的对象封装为另一个类的属性，具体示例为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有一个男孩类和一个女孩类，男孩类中包含多个女孩类的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.girl_f = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ba_mei</span><span class="params">(self, girl)</span>:</span></span><br><span class="line">        self.girl_f.append(girl)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">happy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.girl_f:</span><br><span class="line">            i.play()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>陪你一起玩~o(=•ェ•=)m'</span>)</span><br><span class="line">        </span><br><span class="line">xiaoqiang = Boy(<span class="string">'小强'</span>)</span><br><span class="line"></span><br><span class="line">xiaohong = Girl(<span class="string">'小红'</span>)</span><br><span class="line">xiaoli = Girl(<span class="string">'小丽'</span>)</span><br><span class="line">xiaofei = Girl(<span class="string">'小菲'</span>)</span><br><span class="line"></span><br><span class="line">xiaoqiang.ba_mei(xiaohong)</span><br><span class="line">xiaoqiang.ba_mei(xiaoli)</span><br><span class="line">xiaoqiang.ba_mei(xiaofei)</span><br><span class="line"></span><br><span class="line">xiaoqiang.happy()</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小红陪你一起玩~o(=•ェ•=)m</span><br><span class="line">小丽陪你一起玩~o(=•ェ•=)m</span><br><span class="line">小菲陪你一起玩~o(=•ェ•=)m</span><br></pre></td></tr></table></figure>

<p>组合关系与依赖关系的区别在于，组合关系是将类对象封装为新类的属性来使用，而依赖关系则是将类对象作为参数传给新类的方法使用。</p>
<p>一对多练习：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建教师类和学生类</span><br><span class="line">• 教师类有姓名和学生列表两个属性</span><br><span class="line">• 教师类有添加学生的方法（添加的学生是具体对象）</span><br><span class="line">• 教师类有显示对应学生姓名和学号的方法</span><br><span class="line">• 学生类有学号/姓名/教师姓名三个属性</span><br><span class="line">• 创建多个学生，并添加到某位教师的学生列表中</span><br><span class="line">• 打印该教师的学生</span><br></pre></td></tr></table></figure>

<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.student_list = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_student</span><span class="params">(self, *student)</span>:</span>    <span class="comment"># student前加了*，为了能一次性接收多个实例对象，方便后续使用</span></span><br><span class="line">        self.student_list.extend(student)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> student:</span><br><span class="line">            j.teacher = self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_student</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.student_list:</span><br><span class="line">            print(<span class="string">f'姓名：<span class="subst">&#123;i.name&#125;</span>，学号：<span class="subst">&#123;i.student_id&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, student_id)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.student_id = student_id</span><br><span class="line">        self.teacher = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">alex = Teacher(<span class="string">'Alex'</span>)</span><br><span class="line">bigB = Teacher(<span class="string">'宝元'</span>)</span><br><span class="line"></span><br><span class="line">xiaoming = Student(<span class="string">'小明'</span>, <span class="number">123</span>)</span><br><span class="line">xiaoqiang = Student(<span class="string">'小强'</span>, <span class="number">234</span>)</span><br><span class="line">xiaohong = Student(<span class="string">'小红'</span>, <span class="number">345</span>)</span><br><span class="line">xiaoli = Student(<span class="string">'小丽'</span>, <span class="number">456</span>)</span><br><span class="line">xiaohu = Student(<span class="string">'小虎'</span>, <span class="number">135</span>)</span><br><span class="line"></span><br><span class="line">alex.add_student(xiaoming ,xiaoli)</span><br><span class="line">bigB.add_student(xiaoqiang, xiaohong, xiaohu)</span><br><span class="line"></span><br><span class="line">alex.show_student()</span><br><span class="line">bigB.show_student()</span><br><span class="line"></span><br><span class="line">print(xiaoming.teacher)</span><br><span class="line">print(xiaoqiang.teacher)</span><br></pre></td></tr></table></figure>

<p>需要注意，使用组合关系时，要尽量避免两个或多个类之间混合使用彼此的类对象作为自己的类属性，这样会陷入循环调用的麻烦中，容易引发混乱。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-advanced/inheritance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-advanced/inheritance/" class="post-title-link" itemprop="url">继承（实现）关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="面向对象与继承"><a href="#面向对象与继承" class="headerlink" title="面向对象与继承"></a>面向对象与继承</h3><p>面向对象思想有三大要素：</p>
<ol>
<li>继承</li>
<li>封装</li>
<li>多态</li>
</ol>
<p>面向对象编程（OOP）语言的一个重要功能就是“继承”：</p>
<ul>
<li>它可以使用现有类的所有功能，并在无需重新编写原来类的情况下，对这些功能进行扩展</li>
<li>通过继承创建的新类被称为“子类”或“派生类”，被继承的类被称为“基类”、“父类”或“超类”</li>
<li>在 Python 中，同时支持单继承与多继承</li>
</ul>
<h3 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h3><p>举个例子，我们现在像创建猪、狗和猫三个类，它们都有名字和年龄属性，也都有一个叫的方法。不同的是，猪有吃的方法、狗有看家的方法、猫有抓老鼠的方法。按照之前的学习，我们会将代码写成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'叫'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'吃'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'叫'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">guarding</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'看家'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'叫'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">catch</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'抓老鼠'</span>)</span><br></pre></td></tr></table></figure>

<p>我们发现，虽然实现了需求，但是我们看到，这里面出现了大量的重复代码。如果我们能将这些重复代码封装起来，比如封装到一个动物类中，然后猪、狗和猫分别都继承这个动物类，就可以让代码更加简洁。</p>


<p>具体的实现方法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'叫'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'吃'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">guarding</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'看家'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">catch</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'抓老鼠'</span>)</span><br><span class="line">mimi = Cat(<span class="string">'咪咪'</span>, <span class="number">3</span>)</span><br><span class="line">print(mimi.name, mimi.age)</span><br><span class="line">mimi.bark()</span><br><span class="line">mimi.catch()</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">咪咪 <span class="number">3</span></span><br><span class="line">叫</span><br><span class="line">抓老鼠</span><br></pre></td></tr></table></figure>

<p>实现继承之后，子类将继承父类的属性和方法。</p>
<p>不难看出，继承关系的特点为：</p>
<ul>
<li>增加了类的耦合性（耦合性不宜多，宜精）</li>
<li>减少了重复代码</li>
<li>使得代码更加规范化，合理化</li>
</ul>
<p>组合与继承的对比：</p>
<ul>
<li>组合<ul>
<li>组合是指在新类里面创建原有类的对象，重复利用已有类的功能，是 <code>has-a</code> 的关系（如：猫有腿）</li>
<li>原来类的对象作为整体，以新类的属性的形式存在</li>
</ul>
</li>
<li>继承<ul>
<li>继承允许设计人员根据其他类的实现来定义一个类的实现，是 <code>is-a</code> 的关系（如：猫是动物）</li>
<li>子类可以直接使用父类中的属性和方法，就好像父类的属性和方法已经存在于子类中了一样</li>
</ul>
</li>
</ul>
<p>Python 3 中使用的都是新式类，如果一个类谁都不继承，那么它默认继承 object 类。</p>
<p>继承虽然很好用，但是不能滥用，像之前说的，耦合程度不宜过高，否则逻辑会十分混乱：</p>
<ul>
<li>不要轻易地使用继承，除非两个类之间是 <code>is-a</code> 关系</li>
<li>不要单纯地为了实现代码的重用而使用继承，因为过多的继承会破坏代码的可维护性，当父类被修改的时候，会影响到所有继承自它的子类，从而增加程序的维护难度与成本</li>
<li>总结起来就是：组装的时候使用组合，扩展的时候使用继承</li>
</ul>
<p>回到我们刚才的例子，猪、狗、猫三各类都只有动物一个父类，这种只有一个父类的继承方式，我们称作为单继承。在单继承中，子类可以继承父类的属性和方法，修改父类，所有子类都会受到影响。</p>
<h3 id="isinstance-和-issubclass"><a href="#isinstance-和-issubclass" class="headerlink" title="isinstance 和 issubclass"></a><code>isinstance</code> 和 <code>issubclass</code></h3><ul>
<li><code>isinstance</code>：<ul>
<li>用于检查实例类型</li>
<li><code>isinstance(对象, 类)</code>，用来判断对象是不是该类的实例对象</li>
</ul>
</li>
<li><code>issubclass</code>：<ul>
<li>用于检查类继承</li>
<li><code>issubclass(类1, 类2)</code>，用来判断类1是否是类2的子类</li>
</ul>
</li>
</ul>
<h3 id="类与数据类型"><a href="#类与数据类型" class="headerlink" title="类与数据类型"></a>类与数据类型</h3><p>Python 与其他编程语言不同，当我们定义一个 class 的时候，我们实际上就定义了一个数据类型。我们定义的数据类型和 Python 自带的数据类型，比如 str、list、dict 没什么两样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(isinstance(<span class="number">10</span>, int))</span><br><span class="line"></span><br><span class="line">输出的结果为： <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>如果父类中的方法在子类中不适用，我们可以对其进行重写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'叫'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span>    <span class="comment"># 重写叫的方法</span></span><br><span class="line">        print(<span class="string">'汪汪汪！'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">guarding</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'看家'</span>)</span><br><span class="line">  </span><br><span class="line">wangwang = Dog(<span class="string">'汪汪'</span>, <span class="number">3</span>)</span><br><span class="line">print(wangwang.name)</span><br><span class="line">wangwang.bark()</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">汪汪</span><br><span class="line">汪汪汪！</span><br></pre></td></tr></table></figure>

<p>重写父类方法的原理是，当示例调用方法时，会先在自己的类方法中查找，如果找不到，才会去父类中查找是否有相应的方法。如果在自己的类方法中找到了需要的方法，就不会去父类中查找，也就调用不到父类的同名方法，从而实现对父类中方法的重写</p>


<h3 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h3><p>但是有些时候，我们不得已会写一些重名的方法，比如父类和子类都会有 <code>__init__</code> 构造方法。但是我们在调用子类方法的同时，也希望调用到父类中相应的方法。我们可以通过父类的类名直接调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>:</span></span><br><span class="line">    eye_num = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">live_like_yemen</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'打儿子'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span></span><br><span class="line">    hair_color = <span class="string">'蓝色'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex)</span>:</span></span><br><span class="line">        Father.__init__(self, name, age)</span><br><span class="line">        self.sex = sex</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">live_like_yemen</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'打弟弟'</span>)</span><br><span class="line"></span><br><span class="line">xiaoming = Son(<span class="string">'小明'</span>, <span class="number">16</span>, <span class="string">'男'</span>)</span><br><span class="line">xiaoming.live_like_yemen()</span><br><span class="line">print(xiaoming.name)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打弟弟</span><br><span class="line">小明</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在类中，self 永远指的是调用类的实例化对象。</p>
<h3 id="super-方法"><a href="#super-方法" class="headerlink" title="super 方法"></a>super 方法</h3><p>在上面的例子中，如果没有 <code>Father.__init__(self, name, age)</code> 这行代码，在子类中就无法调用父类的构造方法，因为子类已经重写了构造方法。上面的方法虽然实现了预期的功能，但是并不符合开发规范。</p>
<p>从子类中，调用父类中方法的关键字是 super，上述例子可修改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>:</span></span><br><span class="line">    eye_num = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">live_like_yemen</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'打儿子'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(Father)</span>:</span></span><br><span class="line">    hair_color = <span class="string">'蓝色'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex)</span>:</span></span><br><span class="line">        super().__init__(name, age)    <span class="comment"># 也可以写为super(Son, self).__init__(name, age)</span></span><br><span class="line">        self.sex = sex</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">live_like_yemen</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'打弟弟'</span>)</span><br><span class="line"></span><br><span class="line">xiaoming = Son(<span class="string">'小明'</span>, <span class="number">16</span>, <span class="string">'男'</span>)</span><br><span class="line">xiaoming.live_like_yemen()</span><br><span class="line">print(xiaoming.name)</span><br></pre></td></tr></table></figure>

<p>super 方法：</p>
<ul>
<li>子类如果编写了自己的构造方法，但是没有声明要调用父类的构造方法，而还需要父类的构造函数中初始化的一些属性，就会出现问题</li>
<li>如果子类和父类都有构造函数，子类的构造函数其实是对父类的构造函数的重写。如果不显示调用父类构造函数，父类的构造函数便不会被执行</li>
<li>解决方法：直接使用超类的类名调用超类构造方法，或者使用 super 函数 <code>super(当前类名, self).__init__()</code></li>
</ul>
<p>父类方法重写：</p>
<ul>
<li>子类可以重写父类中的方法</li>
<li>通过 super 关键字可以调用父类中的方法</li>
</ul>
<h3 id="Python-中的多继承"><a href="#Python-中的多继承" class="headerlink" title="Python 中的多继承"></a>Python 中的多继承</h3><p>多重继承和多继承</p>
<ul>
<li><p>多重继承：包含多个间接父类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多继承：有多个直接父类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span><span class="params">(X, Y, Z)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大部分面向对象的编程语言（除了 C++）都只支持单继承，而不支持多继承</p>
<ul>
<li>多继承不仅增加了编程的复杂度，而且很容易导致一些莫名的错误<a href="在编程时，莫名其妙的错误最为可怕，因为不可预测，难以排除。">^1</a></li>
</ul>
</li>
<li><p>Python 虽然在语法上明确支持多继承，但通常推荐如果不是很有必要，尽量不要使用多继承，而是使用单继承</p>
<ul>
<li>这样可以保证编程思路更清晰，而且可以避免很多麻烦</li>
</ul>
</li>
<li><p>如果多个直接父类中包含了同名的方法</p>
<ul>
<li>排在前面的父类中的方法会“遮蔽“排在后面的父类中的同名方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A_method'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B_method'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.method()</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A_method</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="钻石继承和-MRO"><a href="#钻石继承和-MRO" class="headerlink" title="钻石继承和 MRO"></a>钻石继承和 MRO</h3><p>我们刚刚谈到，即便不使用 super 方法，直接使用父类的类名，同样可以实现对父类方法的调用。那为什么更推荐使用 super 方法呢？</p>
<p>这是因为当涉及到比较复杂得多继承关系，比如钻石继承关系时，会出现间接父类会被初始化多次的情况。</p>


<p>比如，我们来看下面这个钻石继承的例子，如果我们使用父类的类名调用构造方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YeYe</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'初始化爷爷类'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QinBa</span><span class="params">(YeYe)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入化亲爸类'</span>)</span><br><span class="line">        YeYe.__init__(self)</span><br><span class="line">        print(<span class="string">'初始化亲爸类'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GanDie</span><span class="params">(YeYe)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入化干爹类'</span>)</span><br><span class="line">        YeYe.__init__(self)</span><br><span class="line">        print(<span class="string">'初始化干爹类'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErZi</span><span class="params">(QinBa, GanDie)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入化儿子类'</span>)</span><br><span class="line">        QinBa.__init__(self)</span><br><span class="line">        GanDie.__init__(self)</span><br><span class="line">        print(<span class="string">'初始化儿子类'</span>)</span><br><span class="line">erzi = ErZi()</span><br></pre></td></tr></table></figure>

<p>我们看到，程序运行后，爷爷类被初始化了两次。</p>


<p>这是因为，当创建儿子对象时，会执行它的构造函数。首先打印的是儿子类中初始化方法的代码，然后执行秦霸的构造方法。在亲爸的构造方法中，也是先打印代码，然后执行爷爷的构造方法。执行完爷爷的构造方法之后，程序继续执行亲爸中剩余的代码，然后回到儿子类中，执行干爹的构造方法。在干爹的构造方法中，又要调用爷爷的构造方法。然后打印剩余代码，直至结束。</p>


<p>我们看到，第五步和第十步都是要调用爷爷的构造方法，爷爷类被初始化了两次。这种情况一来没有必要，会占用很大空间，二来，多次初始化也会带来程序逻辑的混乱。</p>
<p>如果我们改用 super 函数来进行这样的操作，就不会有这些麻烦：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YeYe</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'初始化爷爷类'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QinBa</span><span class="params">(YeYe)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入亲爸类'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'初始化亲爸类'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GanDie</span><span class="params">(YeYe)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入干爹类'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'初始化干爹类'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErZi</span><span class="params">(QinBa, GanDie)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入儿子类'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'初始化儿子类'</span>)</span><br><span class="line">        </span><br><span class="line">erzi = ErZi()</span><br></pre></td></tr></table></figure>

<p>首先，我们发现，在儿子类中，我们只用一行代码指代调用两个直接父类的构造方法。然后，从结果上看，此时，爷爷类只被初始化一次。</p>


<p>而且我们发现，代码的运行情况与多个装饰器装饰一个函数的情况很类似，子类的代码包含着父类的代码，一层套一层的形式。</p>
<p>要解释这个现象，就要引入 super 方法的查找方法：方法解析顺序列表，MRO[^2]。这个列表是 super 解析父类继承顺序的依据，通过 C3 算法实现。使用 C3 算法计算 MRO 列表的方法可以参考我翻译的 <a href="/python-advanced/..\translation\python-MRO">Python 新式类继承关系的 C3 算法</a> 官方文档。</p>
<p>查看 mro 的方法有两种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.mro()</span><br><span class="line">对象名.__class__.mro()</span><br></pre></td></tr></table></figure>

<p>前面例子中的 mro 为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;class '__main__.ErZi'&gt;, &lt;class '__main__.QinBa'&gt;, &lt;class '__main__.GanDie'&gt;, &lt;class '__main__.YeYe'&gt;, &lt;class 'object'&gt;]</span><br></pre></td></tr></table></figure>

<p>我们说过，super 后面什么都不写，默认和 <code>super(当前类名, self)</code> 的写法一样。但事实上，super 的参数除了可以写当前类名外，还可以写它的父类[^3]的类名。此时，会执行在方法解析顺序列表中，该类下一个类的方法。</p>
<p>补充了这些知识，我们就可以解释上面的程序运行的顺序了。</p>


<p>super 关键字详解：</p>
<ul>
<li>基本结构：<code>super(class[, object or class])</code></li>
<li>Python 3 可以直接使用 <code>super().xxx</code> 代替 <code>super(class, self).xxx</code></li>
<li>使用多继承时，会涉及到查找顺序（MRO）、钻石继承等问题<ul>
<li>单继承时，<code>类名.__init__()</code> 的方式和 <code>super().__init__()</code> 的方式调用父类中的方法没有什么差别</li>
<li>使用 <code>类名.__init__()</code> 的方式在钻石继承时，会遇到初始化混乱的问题</li>
</ul>
</li>
</ul>
<p>super 内核的 mro 方法：返回的是一个类的方法解析顺序表（顺序结构）</p>
<ul>
<li><p>我们定义的每一个类，Python 都会计算出一个方法解析顺序（MRO[^2]）列表这也是 super 在父类中查找成员的顺序，它是通过 C3 线性算法来实现的</p>
</li>
<li><p>每个父类[^3]都存在且只在其中出现一次</p>
</li>
<li><p>我们可以通过下面两种方式获得某个类的 mro 列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.mro()</span><br><span class="line">对象名.__class__.mro()</span><br></pre></td></tr></table></figure>
</li>
<li><p>当使用 <code>super(cls, obj)</code> 时，Python 会在 <code>obj</code> 的 <code>mro</code> 列表上搜索 <code>cls</code> 的下一个类</p>
</li>
<li><p>事实上，super 和父类没有实质性的关联，我们也不一定非要把 super 后面的参数写成自己类的名字和 self。我们甚至可以很灵活地给 super 传参数</p>
<ul>
<li><p><code>super(cls, obj)</code> 获得的是 <code>cls</code> 在 obj 的 <code>MRO</code> 列表中的下一个类，<code>cls</code> 可以是任何一个类，<code>obj</code> 可以是任何一个对象，只要合理即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class</span> <span class="title">ErZi</span><span class="params">(Qinba,GanDie)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(ErZi, self).__init__()</span><br><span class="line">        print(<span class="string">'初始化儿子'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在前面我们定义儿子类的时候，如果我们不想调用亲爸的 <code>__init__()</code>，而是要调用干爹的 <code>__init__()</code>，只需把 super 写成 <code>super(Qinba, self).__init__()</code>，也就是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YeYe</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'初始化爷爷类'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QinBa</span><span class="params">(YeYe)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入亲爸类'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'初始化亲爸类'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GanDie</span><span class="params">(YeYe)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入干爹类'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'初始化干爹类'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErZi</span><span class="params">(QinBa, GanDie)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'进入儿子类'</span>)</span><br><span class="line">        super(QinBa, self).__init__()</span><br><span class="line">        print(<span class="string">'初始化儿子类'</span>)</span><br><span class="line"></span><br><span class="line">erzi = ErZi()</span><br></pre></td></tr></table></figure>

<p>其执行顺序为：</p>


</li>
</ul>
</li>
</ul>
<p>[^2]: Method Resolution Order<br>[^3]: 包括直接父类和间接父类</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-basic/hanz_count/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-basic/hanz_count/" class="post-title-link" itemprop="url">使用 Python 统计中文字符的数量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python 基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用来统计汉字字符数量的一个小脚本，可以直接拿到项目中使用。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/python-basic/hanz_count/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-basic/collections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-basic/collections/" class="post-title-link" itemprop="url">collections 模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python 基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>现在有一个列表，我们需要统计每个元素出现的个数，可以通过循环来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">11</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">123</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">32</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">123</span>, <span class="number">21</span>, <span class="number">3</span>]</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    dic[i] = lst.count(i)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">11</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">123</span>: <span class="number">3</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">12</span>: <span class="number">3</span>, <span class="number">32</span>: <span class="number">1</span>, <span class="number">31</span>: <span class="number">1</span>, <span class="number">23</span>: <span class="number">1</span>, <span class="number">21</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 collections 模块的统计功能，将会更便捷地获得我们想要的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">lst = [<span class="number">11</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">123</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">32</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">123</span>, <span class="number">21</span>, <span class="number">3</span>]</span><br><span class="line">print(Counter(lst))    <span class="comment"># 获取的是Counter字典，可以通过dict方法转换为普通字典</span></span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counter(&#123;<span class="number">123</span>: <span class="number">3</span>, <span class="number">12</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">11</span>: <span class="number">1</span>, <span class="number">32</span>: <span class="number">1</span>, <span class="number">31</span>: <span class="number">1</span>, <span class="number">23</span>: <span class="number">1</span>, <span class="number">21</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="有序字典"><a href="#有序字典" class="headerlink" title="有序字典"></a>有序字典</h3><p>Python 3 中的字典已经是有序的了，但是对于 Python 2 来说，还是无序的。有序字典在 Python 2 中还是十分有用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">a = OrderedDict(&#123;<span class="string">'key1'</span>: <span class="number">1</span>, <span class="string">'key2'</span>: <span class="number">2</span>&#125;)</span><br><span class="line">print(a)</span><br><span class="line">print(a[<span class="string">'key1'</span>])</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(<span class="string">'key1'</span>, <span class="number">1</span>), (<span class="string">'key2'</span>, <span class="number">2</span>)])</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以看出，有序字典以一个类似于列表的形式存储。</p>
<h3 id="默认字典"><a href="#默认字典" class="headerlink" title="默认字典"></a>默认字典</h3><p>使用默认字典可以快速对字典进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dic = defaultdict(list)</span><br><span class="line">dic[<span class="string">'key1'</span>].append(<span class="number">10</span>)    <span class="comment"># 默认创建键值对'key1':[]，可以使用append方法增加元素</span></span><br><span class="line">dic[<span class="string">'key2'</span>] = <span class="number">123</span>    <span class="comment"># 将默认值替换</span></span><br><span class="line">dic[<span class="string">'key3'</span>]    <span class="comment"># 默认创建键值对'key3':[]</span></span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultdict(&lt;class 'list'&gt;, &#123;'key1': [10], 'key2': 123, 'key3': []&#125;)</span><br></pre></td></tr></table></figure>

<p>我们从前有一道作业题，把列表中小于 66 的元素放到字典键 <code>&#39;key1&#39;</code> 对应的值的列表中，大于 66 的元素放到字典键 <code>&#39;key2&#39;</code> 对应的值的列表中，从前我们是这样做到的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">dic = &#123;<span class="string">'key1'</span>: [], <span class="string">'key2'</span>: []&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">66</span>:</span><br><span class="line">        dic[<span class="string">'key2'</span>].append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[<span class="string">'key1'</span>].append(i)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<p>更巧妙一点的写法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    dic.setdefault(<span class="string">'key2'</span>, []).append(i) <span class="keyword">if</span> i &gt; <span class="number">66</span> <span class="keyword">else</span> dic.setdefault(<span class="string">'key1'</span>, []).append(i)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<p>使用默认字典，则可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">lst = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">dic = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">66</span>:</span><br><span class="line">        dic[<span class="string">'key2'</span>].append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[<span class="string">'key1'</span>].append(i)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>队列是一种先进先出的数据存储方式，栈则是先进后出的数据存储方式。</p>
<p>Python 中的列表是一种栈：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lst = []</span><br><span class="line">lst.append(<span class="number">1</span>)</span><br><span class="line">lst.append(<span class="number">2</span>)</span><br><span class="line">lst.append(<span class="number">3</span>)</span><br><span class="line">lst.append(<span class="number">4</span>)</span><br><span class="line">lst.append(<span class="number">5</span>)</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop()</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop()</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop()</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop()</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop()</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>

<p>也可以通过在 pop 指定删除第一位的方法模拟成为队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lst = []</span><br><span class="line">lst.append(<span class="number">1</span>)</span><br><span class="line">lst.append(<span class="number">2</span>)</span><br><span class="line">lst.append(<span class="number">3</span>)</span><br><span class="line">lst.append(<span class="number">4</span>)</span><br><span class="line">lst.append(<span class="number">5</span>)</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop(<span class="number">0</span>)</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop(<span class="number">0</span>)</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop(<span class="number">0</span>)</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop(<span class="number">0</span>)</span><br><span class="line">print(lst)</span><br><span class="line">lst.pop(<span class="number">0</span>)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>

<p>双端队列则是可以实现在数据两端灵活删除数据的数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">lst = deque([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line">print(lst)</span><br><span class="line">lst.append(<span class="number">55</span>)    <span class="comment"># 在右侧（后方）插入数据</span></span><br><span class="line">print(lst)</span><br><span class="line">lst.appendleft(<span class="number">66</span>)    <span class="comment"># 从左侧（前方）插入数据</span></span><br><span class="line">print(lst)</span><br><span class="line">lst.pop()    <span class="comment"># 删除后输入的数据（栈）</span></span><br><span class="line">print(lst)</span><br><span class="line">lst.popleft()    <span class="comment"># 删除先输入的数据（队列）</span></span><br><span class="line">print(lst)</span><br><span class="line">lst.insert(<span class="number">2</span>, <span class="number">77</span>)    <span class="comment"># 指定位置插入</span></span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deque([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line">deque([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>])</span><br><span class="line">deque([<span class="number">66</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>])</span><br><span class="line">deque([<span class="number">66</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line">deque([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line">deque([<span class="number">11</span>, <span class="number">22</span>, <span class="number">77</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br></pre></td></tr></table></figure>

<p>编程中主要的数据存储结构有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表，队列，双端队列，单向链表，双向链表</span><br></pre></td></tr></table></figure>

<p>Python 中的垃圾回收机制称为 GC</p>
<p>以引用计数为主，标记清除和分带回收为辅</p>
<h3 id="命名元组"><a href="#命名元组" class="headerlink" title="命名元组"></a>命名元组</h3><p>命名元组用来使用关键字快速找到相应的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">dg = namedtuple(<span class="string">'dg'</span>, [<span class="string">'jd'</span>, <span class="string">'wd'</span>, <span class="string">'gd'</span>])</span><br><span class="line">nt = dg(<span class="number">116</span>, <span class="number">40</span>, <span class="number">8848</span>)</span><br><span class="line">print(nt)</span><br><span class="line">print(nt.jd)</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dg(jd=<span class="number">116</span>, wd=<span class="number">40</span>, gd=<span class="number">8848</span>)</span><br><span class="line"><span class="number">116</span></span><br></pre></td></tr></table></figure>

<p>我们从前学过的 time 模块的结构化时间就是一种命名元组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sliu.vip/python-basic/user-interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="刘硕">
      <meta itemprop="description" content="不成为自己讨厌的人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘硕的技术查阅手册">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python-basic/user-interface/" class="post-title-link" itemprop="url">用户交互语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 13:53:10 / 修改时间：14:53:08" itemprop="dateCreated datePublished" datetime="2020-03-13T13:53:10+08:00">2020-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Python 基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="print-语句"><a href="#print-语句" class="headerlink" title="print 语句"></a><code>print</code> 语句</h3><p>我们在讨论 Python 中基本数据类型时，已经讨论过 print 语句的基本用法，这里只是简单提一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="string">'abc'</span></span><br><span class="line">c = b + <span class="string">'d'</span></span><br><span class="line">print(a)      <span class="comment"># 打印一个变量</span></span><br><span class="line">print(b, c)   <span class="comment"># 打印多个变量</span></span><br></pre></td></tr></table></figure>

<h3 id="input-语句"><a href="#input-语句" class="headerlink" title="input 语句"></a><code>input</code> 语句</h3><p>在 Python 中，用 <code>input()</code> 函数实现用户和程序间的交互。<code>input</code> 是输入的意思。使用示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qq_user = input(<span class="string">"QQ 账号："</span>)    <span class="comment"># 坑 --&gt; 阻塞</span></span><br><span class="line">qq_pwd = input(<span class="string">"QQ 密码："</span>)</span><br><span class="line">print(qq_user, qq_pwd)</span><br></pre></td></tr></table></figure>

<p>当程序运行到 <code>input</code> 语句时，会发生阻塞，等待用户进行输入。程序会一直保持阻塞状态，除非用户输入内容或终止程序。</p>
<p>需要注意的是，在 Python 3 中 <code>input</code> 获取的内容全都是字符串。因为这样的原因，下面的程序会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = input(<span class="string">"请输入数字："</span>)</span><br><span class="line">print(num + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这两行代码的本意是，当用户输入一个数字之后，程序自动输出一个比输入数字大 5 的数字。但是因为 <code>input</code> 获取的内容是字符串，字符串是不能和整型数字进行加和操作的，故而程序报错。我们可以使用 <code>tpye()</code> 函数查看变量的数据类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = input(<span class="string">"请输入数字："</span>)</span><br><span class="line">print(type(num))    <span class="comment"># 查看数据类型</span></span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入数字：<span class="number">12</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="int-和-str-语句"><a href="#int-和-str-语句" class="headerlink" title="int 和 str 语句"></a><code>int</code> 和 <code>str</code> 语句</h3><p>通过使用 <code>int()</code> 函数可以将字符串转化为整型数据。同样地，也可以使用 <code>str()</code> 函数，把整型数据转换成字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = int(<span class="string">'12'</span>)	<span class="comment"># 字符串转成整型</span></span><br><span class="line">b = str(<span class="number">23</span>)		<span class="comment"># 整型转成字符串</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用 <code>int()</code> 函数将字符串转换为整型时，字符串中的内容必须全部都是数字，否则会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'abc123'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'abc123'</span></span><br></pre></td></tr></table></figure>

<p>那么我们上面的例子就可以改成这个样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = input(<span class="string">"请输入数字："</span>)</span><br><span class="line">a = int(num)</span><br><span class="line">print(a + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这样的话，当我们输入一个数字之后，通过 <code>int()</code> 函数，输入内容转换成为整型，然后就可以进行加和操作了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入数字：<span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>也可以把 <code>inpu()</code> 操作直接放到 <code>int()</code> 函数中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = int(input(<span class="string">"请输入数字："</span>))</span><br><span class="line">print(num + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="用户交互语句总结"><a href="#用户交互语句总结" class="headerlink" title="用户交互语句总结"></a>用户交互语句总结</h3><ul>
<li><code>input()</code> 是输入，获取到的内容都是字符串</li>
<li><code>type()</code> 函数用来查看数据类型</li>
<li><code>int(&#39;字符串&#39;)</code> 可以将字符串转换成整型，字符串中的内容必须全部都是数字</li>
<li><code>str(整型)</code> 函数可以将整型转换成字符串</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘硕"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">刘硕</p>
  <div class="site-description" itemprop="description">不成为自己讨厌的人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:liushuo432@outlook.com" title="E-Mail → mailto:liushuo432@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/2436055290" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2436055290" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=1696146913&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;1696146913&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">辽ICP备20001451号 </a>
      <img src="/images/beian_icon.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=21142102000063" rel="noopener" target="_blank">辽公网安备 21142102000063号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘硕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.2" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

  

  <script type="text/javascript" src="/js/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"left","hOffset":-30,"vOffset":-40},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>
</html>
